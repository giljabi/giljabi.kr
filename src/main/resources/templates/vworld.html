<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>3D 지도</title>

    <style>
        #progressBar {
            position: absolute;
            width: 100%;
            background-color: #4caf50;
            text-align: center;
            line-height: 25px;
            color: white;
            z-index: 1;
        }
        /*
        .bottom-div {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: green;
        }
        */
        .top-div {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .parent {
            position: relative;
            border: 1px solid #000;
        }
        .ioClass {
            position:absolute;
            top:10px;
            z-index: 100;
            display: none;
            height:24px;
        }
    </style>
    <!-- API key를 포함하여 브이월드 API URL을 지정하여 호출, https가 아니면 사용하는 domain을 추가해야 함  -->
    <script type="text/javascript"
            src="https://map.vworld.kr/js/webglMapInit.js.do?version=2.0&apiKey=EF0CBEDB-A6FA-3FD9-B1B3-D7C725EF09D3">
    </script>
    <script type="text/javascript" src="/js/jquery-3.3.1.js"></script>
    <script type="text/javascript" src="/js/jquery-ui.js"></script>
    <script type="text/javascript" src="/js/FileSaver.min.js"></script>
    <script type="text/javascript" src="/js/lz-string-1.4.4-min.js"></script>
    <script type="text/javascript" src="/js/routeutil.js"></script>
</head>

<body>
<div class="parent">
    <div id="progressBar" ></div>
    <button id="saveImage" class="ioClass" style="left:10px;">이미지 저장</button>
    <select id="lineWidth" class="ioClass" style="left:100px;">
        <option value="1">라인두께: 1</option>
        <option value="3" selected>라인두께: 3</option>
        <option value="5">라인두께: 5</option>
        <option value="10">라인두께: 10</option>
        <option value="25">라인두께: 25</option>
    </select>
    <select id="lineColor" class="ioClass" style="left:195px;">
        <option value="RED" selected>RED</option>
        <option value="#009dff">Sky Blue</option>
    </select>
    <button id="rotateButton" class="ioClass" style="left:270px;" value="start">Rotate Start</button>
    <button id="flyButton" class="ioClass" style="left:360px;" value="flyStart">Fly Start</button>
    <button id="startButton" class="ioClass" style="left:430px;">Start Recording</button>
    <button id="stopButton" disabled class="ioClass" style="left:545px;">Stop Recording</button>
    <video id="videoPreview" controls></video>

    <div id="vmap" class="top-div" style="width:100vw;height:97vh;position:center;left:0px;top:0px;">
    </div>
</div>
</body>

<script>
    let map;
    let xmlData;
    let gpxLineArray = [];
    let gpxLine;
    let midPos;
    let rotate = null;
    let fly = true;
    let flyLine;

    let mediaRecorder;
    let recordedChunks = [];

    function initMap(home, init) {
        let mapOptions = new vw.MapOptions(
            vw.BasemapType.PHOTO_HYBRID, //vw.BasemapType.GRAPHIC 2D지도 전용
            '', //layersArr 2D지도 전용
            vw.DensityType.FULL, //controlDensity vw.DensityType.FULL 2D지도 전용
            '', //interactionDensity vw.DensityType.BASIC 2D지도 전용
            false, //controlAutoArrange true 2D지도 전용
            home,
            init
        );

        map = new vw.Map("vmap", mapOptions);
        //map.setLogoVisible(false);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    $(document).ready(function() {
        document.addEventListener('wheel', function(event) {
            //console.log(map.getView().getZoom());
            //console.log('wheel event:' + new Date());
        }, { passive: true });

        let gpxdata = '[[${gpxdata}]]';
        xmlData = $(LZString.decompressFromBase64(gpxdata));

        $('#progressBar').text('데이터를 읽고 있습니다. 데이터가 큰 경우 시간이 오래걸리지만 기다려 주세요.');
        $('#progressBar').css('background-color', '#4caf50');

        console.log('5:' + new Date());
        let trpktLength = $(xmlData).find('trkpt').length;
        $(xmlData).find('trkpt').each(function(index) {
            gpxLineArray.push(new vw.Coord(
                Number($(this).attr('lon')),
                Number($(this).attr('lat')))
            );
        });
        console.log('6:' + new Date());

        midPos = gpxLineArray[Math.floor(gpxLineArray.length / 2)];
        let startPos = gpxLineArray[0];

        let cameraHomePosition = new vw.CameraPosition(
            new vw.CoordZ(startPos.x, startPos.y, 5000),
            new vw.Direction(-90, 0, 0)
        );

        let cameraInitPosition = new vw.CameraPosition(
            new vw.CoordZ(midPos.x, midPos.y, 1000),
            new vw.Direction(0, -45, 0)
        );

        initMap(cameraHomePosition, cameraInitPosition);

        $('#saveImage').click(function() {
            let fileName = $(xmlData).find('metadata > name').text();
            if(fileName === '') {
                fileName = new Date().toISOString().replace(/:/g, '-');
            }
            map.saveAsImage(fileName + '.png');
        });

        $('#lineWidth').change(function() {
            //let line = map.getCollection('GPXLINE');
            gpxLine.setWidth(Number($(this).val()));
            gpxLine.redraw();
        });

        $('#lineColor').change(function() {
            gpxLine.setFillColor(vw.Color[$(this).val()]);
            gpxLine.redraw();
        });

        $('#rotateButton').click(function() {
            if($('#rotateButton').val() == 'start')
                rotateEvent();
            else {
                $('#rotateButton').text('Rotate Start').val('start');
                rotate.stop();
            }
        });
        $('#flyButton').click(function() {
            flyAlongPath();
            $('#flyButton').prop('disabled', true);

/*            if($('#flyButton').val() == 'flyStart') {
                //$('#flyButton').text('Fly Stop').val('flyStop');
                //fly = true;
                flyAlongPath();
            } else {
                //$('#flyButton').text('Fly Start').val('flyStart');
                //fly = false;
            }*/
        });

        $('#startButton').click(async function() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true
                });

                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = function() {
                    const blob = new Blob(recordedChunks, {
                        type: 'video/webm'
                    });
                    recordedChunks = [];

                    const url = URL.createObjectURL(blob);
                    $('#videoPreview').attr('src', url);

                    const a = $('<a>')
                        .attr('href', url)
                        .attr('download', 'screen-recording.webm')
                        .appendTo('body');
                    a[0].click();
                    a.remove();
                    URL.revokeObjectURL(url);
                };

                mediaRecorder.start();
                $('#startButton').prop('disabled', true);
                $('#stopButton').prop('disabled', false);
            } catch (err) {
                console.error("Error: " + err);
            }
        });

        $('#stopButton').click(function() {
            mediaRecorder.stop();
            $('#startButton').prop('disabled', false);
            $('#stopButton').prop('disabled', true);
        });
    });

    /**
     * 최대 60초내로 끝내야 하므로 24프레임 * 60초 = 1440프레임
     * trkpt를 1440포인트으로 나누어 계산해서 처리해야 함
     * @returns {Promise<void>}
     */
    async function flyAlongPath() {
        let tilt = -20; // Initial tilt angle
        let decreasing = true; // Direction flag
        let time = 1440 / 2;
        let gpxLineZ = [];
        $(xmlData).find('trkpt').each(function(index) {
            gpxLineZ.push(new vw.CoordZ(
                Number($(this).attr('lon')),
                Number($(this).attr('lat')),
                Number($(this).find('ele').text())));
        });

        //if(flyLine != null) flyLine.remove(); 안됨...

        let flyPolyline = [];
        let flyCollection;
        let interval;

        if(gpxLineZ.length > time)
            interval = Math.ceil(gpxLineZ.length / time);
        else
            interval = 1;

        for(let i = 0; i < gpxLineZ.length; i += interval) {
            if(!fly) {
                console.log('fly false');
                break;
            }
            let movePo = new vw.CoordZ(gpxLineZ[i].x, gpxLineZ[i].y, gpxLineZ[i].z * 3);

            flyPolyline.push(movePo);
            flyCollection = new vw.Collection(flyPolyline);
            flyLine = new vw.geom.LineString(flyCollection);
            flyLine.setFillColor(vw.Color.YELLOW);
            flyLine.setWidth(20);
            flyLine.setName("flyLine");
            flyLine.create();

            if (decreasing) {
                tilt -= 1;
                if (tilt <= -45) {
                    decreasing = false; // Change direction to increasing
                }
            } else {
                tilt += 1;
                if (tilt >= -25) {
                    decreasing = true; // Change direction to decreasing
                }
            }
            let angle = calculateBearing(gpxLineZ[i], gpxLineZ[i + interval]);
            //let angle = i % 360; // Ensures the angle is between 0 and 89

            let direction = new vw.Direction(angle, tilt, 0);
            console.log(i + ',' + direction + ',' + movePo);
            map.moveTo(new vw.CameraPosition(movePo, direction));
            await conditionalSleep(500);
        }
    }
    function toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }

    // Function to convert radians to degrees
    function toDegrees(radians) {
        return radians * (180 / Math.PI);
    }

    // Function to calculate initial bearing between two points
    //2지점이 아니라 2지점 사이에 있는 것과 다음 2지점 사이의 평균의 방향을 구하면 어떨지...
    function calculateBearing(start, end) {
        const lat1 = toRadians(start.y);
        const lat2 = toRadians(end.y);
        const deltaLong = toRadians(end.x - start.x);

        const y = Math.sin(deltaLong) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLong);

        let bearing = Math.atan2(y, x);
        bearing = toDegrees(bearing);
        bearing = (bearing + 360) % 360; // Normalize to 0-360

        return bearing;
    }

    function conditionalSleep(ms) {
        return new Promise(resolve => {
            const interval = 50; // Check every 50ms
            let elapsed = 0;
            const checkFly = () => {
                if (!fly) {
                    console.log("Sleep interrupted due to fly being false.");
                    resolve();
                    return;
                }
                elapsed += interval;
                if (elapsed >= ms) {
                    resolve();
                } else {
                    setTimeout(checkFly, interval);
                }
            };
            setTimeout(checkFly, interval);
        });
    }

    function rotateEvent() {
        let startMidDistance = getDistance(
            { lng: gpxLineArray[0].x, lat: gpxLineArray[0].y},
            { lng: midPos.x, lat: midPos.y});

        let midToEndDistance = getDistance(
            { lng: midPos.x, lat: midPos.y},
            { lng: gpxLineArray[gpxLineArray.length - 1].x, lat: gpxLineArray[gpxLineArray.length - 1].y});

        let altitude;
        startMidDistance > midToEndDistance ?
            altitude = startMidDistance * 1.5 :
            altitude = midToEndDistance * 1.5;

        let centerPos = new vw.CoordZ(midPos.x, midPos.y, 0);
        rotate = new vw.cameraAction.Rotate(centerPos, altitude);
        rotate.setTarget(centerPos);
        rotate.setDistance(altitude);
        rotate.start();
        $('#rotateButton').text('Rotate Stop').val('stop');

    }

    vw.ws3dInitCallBack = function() {
        let polyline = new vw.Collection(gpxLineArray);
        gpxLine = new vw.geom.LineString(polyline);
        gpxLine.setFillColor(vw.Color.RED);
        gpxLine.setWidth(5);
        gpxLine.setName("GPXLINE");
        gpxLine.create();

        makeWaypointMark();

        $('#progressBar').text('지도가 준비되었습니다.');
        $('#progressBar').fadeOut(1000);
        $('.ioClass').show();
    }

    function makeWaypointMark() {
        let markImage = 'https://map.vworld.kr/images/v2map/spotmarker.png';

        $(xmlData).find('wpt').each(function() {
            let markPos = new vw.Coord(
                Number($(this).attr('lon')),
                Number($(this).attr('lat')));

            let labelOptions = {
                showBackground : true // 라벨 백그라운드 적용유무
                , backgroundColor : ws3d.common.Color.fromCssColorString('#FFFFFF').withAlpha(1) // 백그라운드 css색상으로 부터 color생성하기
                , text: $(this).find('name').text() // 라벨 적용.
                , font: '12px Gothic, sans-serif'// 글자폰트
                , fillColor: ws3d.common.Color.fromCssColorString('#000000') // 글자색상
                , disableDepthTestDistance: Number.POSITIVE_INFINITY // 라벨이 지형에 파뭍히지 않도록 설정.
                , style : ws3d.common.LabelStyle.FILL // 라벨 글자 안쪽 및 외곽 색상 채우기 FILL, FILL_AND_OUTLINE, OUTLINE
                , pixelOffset : new ws3d.common.Cartesian2(0, -2) // 생략가능. 생략시 마커 위에 표시됨. x : 0 - 가운데, (음수)-50 - 왼쪽방향, (양수)50 - 오른쪽방향, y : 0 - 아이콘 바로 위, (음수)-50 : 위쪽 방향, (양수) 50 : 아래쪽방향
            };

            map.createMarker('', markPos.x, markPos.y, '', markImage, 0, 0, 0, labelOptions);
        });
    }
</script>

</html>